{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useGeolocated = void 0;\nconst react_1 = require(\"react\");\n/**\n * Hook abstracting away the interaction with the Geolocation API.\n * @param config - the configuration to use\n */\nfunction useGeolocated() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    positionOptions = {\n      enableHighAccuracy: true,\n      maximumAge: 0,\n      timeout: Infinity\n    },\n    isOptimisticGeolocationEnabled = true,\n    userDecisionTimeout = undefined,\n    suppressLocationOnMount = false,\n    watchPosition = false,\n    geolocationProvider = typeof navigator !== \"undefined\" ? navigator.geolocation : undefined,\n    onError,\n    onSuccess\n  } = config;\n  const userDecisionTimeoutId = (0, react_1.useRef)(0);\n  const isCurrentlyMounted = (0, react_1.useRef)(true);\n  const watchId = (0, react_1.useRef)(0);\n  const [isGeolocationEnabled, setIsGeolocationEnabled] = (0, react_1.useState)(isOptimisticGeolocationEnabled);\n  const [coords, setCoords] = (0, react_1.useState)();\n  const [timestamp, setTimestamp] = (0, react_1.useState)();\n  const [positionError, setPositionError] = (0, react_1.useState)();\n  const cancelUserDecisionTimeout = (0, react_1.useCallback)(() => {\n    if (userDecisionTimeoutId.current) {\n      window.clearTimeout(userDecisionTimeoutId.current);\n    }\n  }, []);\n  const handlePositionError = (0, react_1.useCallback)(error => {\n    cancelUserDecisionTimeout();\n    if (isCurrentlyMounted.current) {\n      setCoords(() => undefined);\n      setIsGeolocationEnabled(false);\n      setPositionError(error);\n    }\n    onError === null || onError === void 0 ? void 0 : onError(error);\n  }, [onError, cancelUserDecisionTimeout]);\n  const handlePositionSuccess = (0, react_1.useCallback)(position => {\n    cancelUserDecisionTimeout();\n    if (isCurrentlyMounted.current) {\n      setCoords(position.coords);\n      setTimestamp(position.timestamp);\n      setIsGeolocationEnabled(true);\n      setPositionError(() => undefined);\n    }\n    onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(position);\n  }, [onSuccess, cancelUserDecisionTimeout]);\n  const getPosition = (0, react_1.useCallback)(() => {\n    if (!geolocationProvider || !geolocationProvider.getCurrentPosition || !geolocationProvider.watchPosition) {\n      throw new Error(\"The provided geolocation provider is invalid\");\n    }\n    const funcPosition = (watchPosition ? geolocationProvider.watchPosition : geolocationProvider.getCurrentPosition).bind(geolocationProvider);\n    if (userDecisionTimeout) {\n      userDecisionTimeoutId.current = window.setTimeout(() => {\n        handlePositionError();\n      }, userDecisionTimeout);\n    }\n    watchId.current = funcPosition(handlePositionSuccess, handlePositionError, positionOptions);\n  }, [geolocationProvider, watchPosition, userDecisionTimeout, handlePositionError, handlePositionSuccess, positionOptions]);\n  (0, react_1.useEffect)(() => {\n    if (!suppressLocationOnMount) {\n      getPosition();\n    }\n    return () => {\n      cancelUserDecisionTimeout();\n      if (watchPosition && watchId.current) {\n        geolocationProvider === null || geolocationProvider === void 0 ? void 0 : geolocationProvider.clearWatch(watchId.current);\n      }\n    };\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n  return {\n    getPosition,\n    coords,\n    timestamp,\n    isGeolocationEnabled,\n    isGeolocationAvailable: Boolean(geolocationProvider),\n    positionError\n  };\n}\nexports.useGeolocated = useGeolocated;","map":{"version":3,"names":["Object","defineProperty","exports","value","useGeolocated","react_1","require","config","arguments","length","undefined","positionOptions","enableHighAccuracy","maximumAge","timeout","Infinity","isOptimisticGeolocationEnabled","userDecisionTimeout","suppressLocationOnMount","watchPosition","geolocationProvider","navigator","geolocation","onError","onSuccess","userDecisionTimeoutId","useRef","isCurrentlyMounted","watchId","isGeolocationEnabled","setIsGeolocationEnabled","useState","coords","setCoords","timestamp","setTimestamp","positionError","setPositionError","cancelUserDecisionTimeout","useCallback","current","window","clearTimeout","handlePositionError","error","handlePositionSuccess","position","getPosition","getCurrentPosition","Error","funcPosition","bind","setTimeout","useEffect","clearWatch","isGeolocationAvailable","Boolean"],"sources":["/Users/rohanchopra/Documents/gitrohangit/click-counter/node_modules/react-geolocated/dist-modules/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useGeolocated = void 0;\nconst react_1 = require(\"react\");\n/**\n * Hook abstracting away the interaction with the Geolocation API.\n * @param config - the configuration to use\n */\nfunction useGeolocated(config = {}) {\n    const { positionOptions = {\n        enableHighAccuracy: true,\n        maximumAge: 0,\n        timeout: Infinity,\n    }, isOptimisticGeolocationEnabled = true, userDecisionTimeout = undefined, suppressLocationOnMount = false, watchPosition = false, geolocationProvider = typeof navigator !== \"undefined\"\n        ? navigator.geolocation\n        : undefined, onError, onSuccess, } = config;\n    const userDecisionTimeoutId = (0, react_1.useRef)(0);\n    const isCurrentlyMounted = (0, react_1.useRef)(true);\n    const watchId = (0, react_1.useRef)(0);\n    const [isGeolocationEnabled, setIsGeolocationEnabled] = (0, react_1.useState)(isOptimisticGeolocationEnabled);\n    const [coords, setCoords] = (0, react_1.useState)();\n    const [timestamp, setTimestamp] = (0, react_1.useState)();\n    const [positionError, setPositionError] = (0, react_1.useState)();\n    const cancelUserDecisionTimeout = (0, react_1.useCallback)(() => {\n        if (userDecisionTimeoutId.current) {\n            window.clearTimeout(userDecisionTimeoutId.current);\n        }\n    }, []);\n    const handlePositionError = (0, react_1.useCallback)((error) => {\n        cancelUserDecisionTimeout();\n        if (isCurrentlyMounted.current) {\n            setCoords(() => undefined);\n            setIsGeolocationEnabled(false);\n            setPositionError(error);\n        }\n        onError === null || onError === void 0 ? void 0 : onError(error);\n    }, [onError, cancelUserDecisionTimeout]);\n    const handlePositionSuccess = (0, react_1.useCallback)((position) => {\n        cancelUserDecisionTimeout();\n        if (isCurrentlyMounted.current) {\n            setCoords(position.coords);\n            setTimestamp(position.timestamp);\n            setIsGeolocationEnabled(true);\n            setPositionError(() => undefined);\n        }\n        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(position);\n    }, [onSuccess, cancelUserDecisionTimeout]);\n    const getPosition = (0, react_1.useCallback)(() => {\n        if (!geolocationProvider ||\n            !geolocationProvider.getCurrentPosition ||\n            !geolocationProvider.watchPosition) {\n            throw new Error(\"The provided geolocation provider is invalid\");\n        }\n        const funcPosition = (watchPosition\n            ? geolocationProvider.watchPosition\n            : geolocationProvider.getCurrentPosition).bind(geolocationProvider);\n        if (userDecisionTimeout) {\n            userDecisionTimeoutId.current = window.setTimeout(() => {\n                handlePositionError();\n            }, userDecisionTimeout);\n        }\n        watchId.current = funcPosition(handlePositionSuccess, handlePositionError, positionOptions);\n    }, [\n        geolocationProvider,\n        watchPosition,\n        userDecisionTimeout,\n        handlePositionError,\n        handlePositionSuccess,\n        positionOptions,\n    ]);\n    (0, react_1.useEffect)(() => {\n        if (!suppressLocationOnMount) {\n            getPosition();\n        }\n        return () => {\n            cancelUserDecisionTimeout();\n            if (watchPosition && watchId.current) {\n                geolocationProvider === null || geolocationProvider === void 0 ? void 0 : geolocationProvider.clearWatch(watchId.current);\n            }\n        };\n    }, []); // eslint-disable-line react-hooks/exhaustive-deps\n    return {\n        getPosition,\n        coords,\n        timestamp,\n        isGeolocationEnabled,\n        isGeolocationAvailable: Boolean(geolocationProvider),\n        positionError,\n    };\n}\nexports.useGeolocated = useGeolocated;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}